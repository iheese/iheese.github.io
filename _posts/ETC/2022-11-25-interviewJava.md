---
layout: post
title: 'Java Interview 대비'
subtitle: 'JVM, GC, OOP, API, JDBC'
date: 2023-06-14 12:00:00 +0900
categories: 'ETC'
background: '/img/posts/etc/git.png'

---

#### JVM의 구조와 Java의 실행방식을 설명해주세요

- JVM(Java Virtual Machine), 자바와 운영체제 사이의 중개자 역할을 한다. 가비지 컬렉터를 사용한 메모리 관리도 자동으로 수행하고, 스택 기반으로 동작한다.
> - 덕분에 운영체제에 구애받지 않고 프로그램을 실행할 수 있다.

- 실행방식
1. 자바 컴파일러(javac)에 의해 자바 소스 파일(.java)이 바이트 코드(.class)로 변환된다.
2. Class Loader를 통해 class 파일들을 JVM으로 로딩한다.
3. 로딩된 class 파일들을 Excution engine을 통해 해석됩니다.
4. 해석된 바이트 코드는 Runtime Data Areas에 배치되어 실질적인 수행이 이뤄집니다. 

- 구조 :
> - Class Loader : JVM 내로 클래스 파일을 로드, 링크를 통해 배치하는 작업을 수행하는 모듈, 런타임 시 동적으로 로드한다.
> - Garbage Collector : 힙 메모리 영역 참조되지 않은 객체 탐색 후 제거한다.
> - Execution Engine : Runtime Data Area에 배치된 바이트 코드를 명령어 단위로 읽어서 실행한다.
> > - 인터프리터 방식에서 JIT 컴파일러 방식으로 보완되었다.
> > > -  JIT 컴파일러는 반복되는 코드를 발견하면 바이트 코드를 어셈블리어 같은 네이티브 코드로 바꿉니다. 실행이 빠르지만 변환 비용이 비교적 크게 발생한다.
> > > -  그러므로 JVM은 모든 코드를 JIT 컴파일러 방식으로 실행하지 않고 인터프리터 방식을 사용하다가 일정 기준이 넘어가면 JIT 컴파일러 방식으로 실행한다. 
> - Runtime Data Area : 자바 애플리케이션이 실행될 때 사용되는 데이터들을 적재하는 영역이다. (Method Area, Heap Area, Stack Area, PC Register, Native Method Stack)

<br>

#### JVM 메모리 구조에 대해 알고 있나요?
- JVM 메모리는 Runtime Data Area에 저장이 되며 메소드 영역, 힙 영역, 스택 영역, PC레지스터 영역, 네이티브 메소드 스택 영역으로 나누어집니다. 
> - 메소드 영역 : 모든 스레드가 공유하며 바이트코드로 변환된 것들을 저장합니다.(클래스, 인터페이스, 메소드, 필드, static 변수 등)
> - 힙 영역 : 모든 스레드가 공유하며, new 키워드로 생성된 객체와 배열이 저장되는 영역입니다. 클래스 영역에 로드된 클래스로 생성이 가능하고 GC가 참조되지 않는 메모리를 확인하고 제거합니다.
> - 스택 영역 : 메소드 호출 마다 스택 프레임(그 메소드를 위한 공간)이 생성됩니다. 메소드 안에서 사용되는 값(매개변수, 지역변수, 리턴 값 연산 시 일어나는 값)을 저장하고 메소드 수행이 끝나면 프레임별로 삭제합니다.
> - PC 레지스터 : 스레드가 시작될 때 생성되며, 스레드마다 하나씩 존재합니다. 스레드가 어떤 명령으로 실행해야 할 지에 대한 기록을 하는 부분으로 JVM 명령의 주소를 갖습니다.
> - 네이티브 메소드 스택 영역 : 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역입니다. 

<br>

### JIT(Just-In-Time) 컴파일러에 대해 알고 있나요?
- JVM의 Execution Engine에서 런타임 시 바이트 코드를 기계어로 변환하여 실행할 때 인터프리터를 이용합니다. 하지만 컴파일 언어에 비해 성능이 매우 떨어지게 됩니다. 이 때 사용되는 것이 JIT 컴파일러입니다. 
- 자주 실행되는 바이트 코드 영역을 런타임 중에 기계어로 컴파일하여 사용하는 것입니다. 


<br>

#### GC가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명해주세요.

- GC(Garbage Collection), 힙 영역에서 사용하지 않는 객체들을 제거하는 작업을 총징한다. 자바 언어는 개발자가 메모리를 직접 해제하는 언어가 아니기 때문이 이 작업은 꼭 필요하다. 
- GC의 영역
> - Minor GC : young 영역, 새롭게 생성된 객체가 할당 되는 영역, 먾은 객체가 Young 영역에 생성되었다 사라집니다.
> > - eden 1개, survivor 2개로 구성되어 있다. eden 영역이 가득차면 survivor로 넘어가면서 실행된다.
> > - 크기가 작아서 GC 시간이 작다.
> - Major GC : old 영역, 특정 횟수 이상을 살아남은 참조 변수가 살아있는 곳입니다.
> > - survivor 2번쨰까지 들렸다가 사용되면 Old 영역으로 오게된다.
> > - Old 영역이 가득차면 Major GC가 발생한다.
- GC의 동작 방식
> - Stop The World : GC를 수행하기 위해 JVM이 어플리케이션의  실행을 멈추는 작업을 말합니다. GC를 실행하는 스레드를 제외한 모든 스레드들의 작업이 중단되고 GC가 완료되면 작업이 재개됩니다. 
> > - 스레드의  작업이 중단되면 어플리케이션이 멈추기 때문에 GC 성능 튜닝을 한다고 하면 이 부분의 시간을 줄이는 작업을 말합니다.
> > - 특히 Old 영역은 크기가 크기 때문에 Major GC 시간이 오래걸린다.
> - Mark And Sweep : 모든 작업이 중단되면 GC는 스택의 모든 변수 또는 Reachable 객체(어디선가 사용하고 있는 객체, Unreachable : 아무도 사용하지 않고 자리만 차지하고 있는 객체)를 스캔하면서 각각 어떤 객체를 참조하고 있는지 탐색하게 됩니다. 그리고 사용되고 있는 메모리를 식별하고 사용되지 않는 객체를 제거합니다. 
- [[JAVA] Garbage Collection의 개념과 동작 원리](https://hajoung56.tistory.com/43)

<br>

#### 오버라이딩과 오버로딩이 무엇이며 어떤 차이가 있을까요?
- 오버라이딩 : 상위 클래스의 메소드를 재정의하는 것을 의미한다.(런타임 다형성)
> - 이름, 매개변수, 리턴타입이 같고, 메소드 내용이 달라야 한다.
- 오버로딩 : 같은 클래스 내 동일한 메소드 이름을 가지지만 매개변수의 타입, 갯수를 다르게 구현할 수 있는 것을 의미한다. (컴파일 다형성)
> - 메소드 이름이 같아야 하며, 매개변수 갯수, 타입이 달라야 한다.
> - 리턴타입만 다르면 성립이 되지 않고, 매개변수와 함께 달라져야 성립된다. 

<BR>

#### 객체지향 프로그래밍에 대해서 설명해주세요.

- 모든 데이터를 객체 취급하며, 처리 요청을 받은 객체는 객체 내부 기능을 사용해 요청을 처리합니다.
- 특징으로 캡슐화, 상속, 다형성, 추상화가 있습니다. 모듈 재사용성이 좋아 확장 및 유지보수가 용이합니다.
> - 캡슐화 : 클래스 내부 변수와 메소드를 하나로 패키징하는 것
> > - 정보 은닉 : 객체 내부 구현을 숨김으로써 객체가 반드시 정해진 메소드를 통해 상호작용하도록 유도하는 것
> > - 접근 제어자를 통해 구현
> > > - public : 다른 객체에서 해당 객체 인스턴스 생성하여 접근 가능
> > > - protected : 해당 객체를 상속받은 객체 내부에서 접근 가능
> > > - default : 동일한 패키지 내의 객체에서 인스턴스 생성하여 접근 가능
> > > - private : 선언된 객체 내부에서만 사용 가능
> - 상속 : 보통 하위 클래스가 상위 클래스를 상속 받게 됩니다. 상속받은 하위 클래스는 상위 클래스의 변수와 메소드를 사용할 수 있게 되고 메소드를 오버라이딩하여 사용할 수 있게 됩니다. 코드의 재사용성이 높아지고 중복을 줄일 수 있게 됩니다.
> - 다형성 : 하나의 객체가 여러 가지 타입을 가질 수 있는 것을 의마합니다. 부모 클래스의 참조변수로 자식 클래스의 인스턴스를 참조할 수 있게 구현합니다.
> - 추상화 : 공통된 부분을 뽑아서 상위 클래스로 뽑아내는 것을 의미힙니다. 중복 코드를 줄일 수 있고, 재사용성을 높이고 가독성을 상승시킬 수 있다. 

<BR>

#### try-with-resource에 대해서 설명해주세요.
- 자바7 이전에 try-catch-finally의 문제점으로 개발자가 close()를 통해 마지막에 자원을 해제시켜주는 것을 누락하거나, 자원 해제를 해줘도 중복 코드가 발생하기 때문에 가독성을 해치는 단점이 있었다.
- 자바 7 이후에 try(객체 선언)을 해주면 로직 처리 여부와 상관없이 JVM에서 자원을 해제시켜주는 기능이다.
- 자바 9 부터는 try 문 밖에서 객체를 선언하고 인스턴스 변수를 넣는 형태로 바뀌었다.  

<br>

#### API란?
- Application Progamming Interface
- API는 프로그램들이 서로 상호작용하는 것을 도와주는 매개체
> - 서버와 데이터베이스에 대한 출입구 역할을 한다.
- 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다.

<br>

#### JDBC API이란
-  Java DataBase Connectivity의 줄임말, 자바 프로그램 내에서 DB 상관없이 DB와 관련된 작업을 처리해주는 API이다.

<br>

#### SOLID(객체지향 5대원칙)에 대해서 설명해주세요.
- SRP(Single Responsibility Principle, 단일 책임 원칙) : 한 클래스는 하나의 책임만 가져야 합니다. 즉 클래스는 그 책임읠 완전히 캡슐화해야 함을 말한다. 
- OCP(Open Closed Principle, 개방 폐쇄 원칙) : 확장에는 열려 있어야 하나 변경에는 닫혀 있어야 합니다. 이를 적용하기 위핸 중요 메커니즘은 추상화와 다형성입니다. 
- LSP(Liskov Substitution Principle, 리스코프 치환 법칙) : 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 합니다. 상위 타입을 상속해서 재정의했을 대 프로그램에 에러가 없어야 합니다.
- DIP(Dependency Inversion Principle, 의존관계 역전 원칙) : 추상적인 것은 구체적인 것에 의존하지 않고, 변화하기 쉬운 것에 의존하면 안된다는 것입니다. 구체적으로는 구현 클래스에 의존하지 말고 인터페이스에 의존해야 하는 원칙입니다. 
> - DIP를 따르는 인기 있는 방법은 DI(의존성 주입)을 활용하는 것이다.
- ISP(Interface Segregation Principle, 인터페이스 분리 원칙) : 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안되는 원칙입니다. 범용 인터페이스 보다는 여러 개의 인터페이스로 분리해야합니다. 
> - SRP, ISP는 같은 문제에 대한 두 가치 다른 해결책이라고 볼 수 있습니다. 가능한 최소한의 인터페이스를 사용하도록 하여 단일 책임을 강조한다고 볼 수 있습니다.
> - 일반적으로 ISP보다 SRP 할 것을 권장합니다.

<br>
#### 클래스, 인스턴스,객체는 무엇인가요?
- 클래스 :  객체를 정의하는 틀, 설계도와 같은 의미로 사용됩니다.(메소드 영역에 저장)
- 인스턴스 : 클래스를 이용해 생성된 객체를 인스턴스라 합니다. (힙 영역에 저장)
- 객체 : 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있고 다른 것과 식별 가능한 것을 의미합니다.  


<br>
#### 자바의 원시타입들은 무엇이 있으며 각각 몇 바이트를 차지하나요?
- 정수형 byte : 1, short : 2, int : 4, long : 8
- 실수형 float : 4, double : 8
- 문자형 char : 2
- 논리형 boolean : 1

<br>

#### 컬렉션 프레임워크에 대해서 설명해주세요.
- 널리 알려져 있는 자료구조를 바탕으로 객체, 데이터들을 효율적으로 관리할 수 있는 자료구조들이 있는 라이브러리를 말합니다.

#### Stream이란?
- 데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소입니다.
- Stream의 경우 반복을 알아서 처리하고 결과값을 어딘가에 저장하는 내부반복을 사용합니다. 
- 덕분에 직접 반복문을 적을 필요가 없으며, 병렬성 처리에 이점이 있습니다.
> - 내부반복을 이용하기 때문에 스레드 공유자원에 대한 동기화를 관리해줄 필요가 없습니다. 
- 예시 :  filter, distinct, map, reduce 등

<br>

#### 제네릭에 대해서 설명해주세요.
- 제너릭은 자바의 타입 안정성을 맡고 있습니다. 컴파일 과정에서 타입체크를 해주므로 객체의 타입 안정성을 높이고 형변환의 번거로움을 줄여줍니다.

<br>

#### 어노테이션에 대해서 설명해주세요.
- 어노테이션은 인터페이스를 기반으로 한 문법으로 주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나 기능을 주입할 수 있습니다. 

<br>

#### 인터페이스와 추상클래스의 차이점에 대해 설명해주세요.
- 인터페이스 
> -  모든 메소드가 추상메소드로 이루어져 있는 것을 말합니다.
> - 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용합니다. 
> - 다중 상속이 가능하고 인터페이스를 상속하는 집합 간에는 연관관계가 없습니다.
- 추상클래스 
> - 클래스 내 하나의 이상의 추상 메소드(abstract)를 포함한 경우를 말합니다. 
> - 객체의 추상적인 상위 개념으로 공통된 개념을 표현할 때 사용합니다.
> - 단일 상속만 가능하고, 추상 클래스를 상속하는 집합 간에는 연관관계가 있습니다.

<br>

#### 정적(static)이란 무엇인가요?
- static은 클래스 멤버라고 합니다. JVM의 클래스 로더가 클래스를 로딩해서 Runtime Data Area의 메소드 영역에 저장할 때 클래스별로 관리됩니다. 
- static 키워드를 통해 생성된 정적멤버들은 Permanent Generation(자바7) 또는 Metaspace(자바8부터)에 저장되고 해당 메모리는 모든 객체가 공유하게 됩니다.
- 하지만 GC 관리 밖에 존재하기 때문에 프로그램 종료까지 존재하게 됩니다. 남발하게 되면 시스템 성능에 문제가 될 수 있습니다. 

<br>

#### 접근 제어자의 종류와 이에 대해 설명해주세요.
- private : 해당 클래스 내에서만 접근 가능
- default : 같은 패키지 내에서만 접근 가능
- protected : 상속한 클래스까지 접근 가능, 다른 패키지여도 자식 클래스면 접근 가능하다. 
- public : 전체 영역에서 접근 가능

<br>

#### final이 클래스, 메소드, 변수에 붙었을 때 차이를 알고 있나요?
- final + 클래스 : 상속이 불가하다.
- final + 메소드 : 오버라이딩이 불가하다.
- final + 변수 : 상수화되어 수정이 불가하다.

<br>

#### Java8에서 추가된 기능에 대해서 설명해주세요.
- Java8부터 Lambda식, Stream API, Optional, 날짜 시간 API, StringJoiner 등이 추가되었습니다. 또한 Permanent Generation이 사라지고 Metaspace 영역(Native 메모리 영역에 속함)이 생겼습니다.
> - Permanent Generation은 Class, Method Code가 저장되는 영역이며 힙 영역에 속했다.
> - Classloader가 현재까지 로드한  Class의 Metadata가 저장되는 공간이며 Native 메모리 영역에 속한다. 또한 크기 제한이 없다. 
> > - Metadata : 데이터에 대한 데이터를 의미한다. 다른 데이터를 설명하기 위한 데이터를 말하고 구조화된 정보를 분석, 분류하고 정보를 추가하기 위해 그 데이터에 뒤를 따라 가는 정보를 말한다. 

#### Java11에서 추가된 기능에 대해서 설명해주세요.
- Java11부터 String 클래스의 메소드, 컬렉션 인터페이스에서 toArray()  메소드를 오버로딩하는 메소드, javac 컴파일 없이 바로 실행 가능, GC 버전 G1 GC로 변경되었습니다. 

<br>

#### 동일성(identity)와 동등성(equality)에 대해 설명해주세요. (equals(), ==)
- 동일성은 참조하는 객체가 같은 것을 의미하고 동등성은 객체의 값이 같은 것을 의미합니다. 
- 기본적으로 equals()는 동일성 비교를 합니다. 따라서 원한다면 메소드를 오버라이딩해서 동등성을 판단할 때 사용하면 됩니다. 

<br>

#### 원시타입과 참조타입의 차이에 대해 설명해주세요.
- 원시타입은 정수, 실수, 논리를 직접 저장하는 8개의 타입을 말한다. 변수마다 사용할 수 있는 값의 범위가 있고 기본값이 존재한다. 원시타입은 스택에 저장이 된다. 
> - 범위를 넘어가면 오버플로우 발생
- 참조타입은 원시타입을 제외한 모두를 일컫는다. 번지를 통해 객체를 참조한다는 뜻이다. Object 클래스를 상속하거나, Object 클래스입니다. 참조 타입은 힙 영역에 저장이 된다.

<br>

#### Checked Exception과 Unchecked Exception에 대해 설명해주세요. 스프링 트랜잭션 추상화에서 rollback 대상은 무엇일까요?
- 둘의 차이는 RuntimeException을  상속하는가의 여부에 따라 다릅니다. RuntimeException을 상속하면 UncheckedException입니다. 
- 스프링 트랜잭션 추상화 rollback 대상은 UncheckedException입니다.
- CheckedException은 컴파일 실행이 안되기 때문에 예외 처리를 꼭 해줘야 한다. 

<br>
#### 자바에서 null을 안전하게 다루는 방법에 대해 설명해주세요.
- Spring Assert를 이용해 null 방어하는 방법
- 자바8부터 추가된 Optional 객체로 감싸는 방법 
- 롬복의 @NonNull을 사용하는 방법 
- 엔티티 필드를 검증하기 위해  @NotNull을 사용하는 방법
> - @Column(nullable = false)은 JPA가 만든 엔티티 필드 값이 Null로 채워져서 정상적으로 처리되다가 DB에 도착한 순간 NOT NULL 옵션이 발생하여 예외처리가 된다.
> - @NotNull은 필드값이 Null로 채워지는 순간 예외가 처리된다. @NotNull이 더 빠른 단계에서 예외를 검출한다. 
> - [@NotNull vs @Column(nullable = false)_현구막](https://hyeon9mak.github.io/not-null-vs-column-nullable-false/)
- 예외 처리를 다른 곳에서 한다면 @NotNull(message="~~") 를 이용하여 null값이 오면 메세지로 리턴해주는 방법

<br>

#### String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.
- String은 불변입니다. 그래서 StringBuilder, StringBuffer를 사용하는 가변 타입입니다. 
- StringBuilder는 Thread-safe하지 않습니다. 따라서 멀티 스레드 환경일 때는 StringBuffer를 사용합니다. 

<br>

#### 강한 결합과 느슨한 결합이 무엇인지 설명해주세요.
- 결합도는 의존성의 정도를 나타냅니다. 다른 모듈에 대해 얼마나 많은 정보를 알고 있는지에 대한 척도입니다.
- 어떤 모듈이 다른 모듈에 대해 필요한 정보(인터페이스로 추상화된 고수준의 정책)만 알고 있다면 두 모듈은 낮은 결합도를 가진다고 합니다.
- 객체지향 관점에서 결합도는 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계를 유지하고 있는지를 나타냅니다. 그러므로 강한 결합도는 지양해야 하고 적절한 결합도를 유지할 수 있도록 고민하고 설계해야 합니다. 

<br>

#### Mutable 객체와 Immutable 객체의 차이점에 대해 설명해주세요.
- Mutable 객체는 가변 객체입니다. class의 인스턴스가 생성된 이후 내부 상태가 변경 가능한 객체입니다.
> - 멀티 스레드 환경에서 사용하려면 별도의 동기화 처리가 필요합니다.
> - 대표적으로 ArrayList, HashMap, StringBuilder, StringBuffer(멀티스레드 환경에서 사용) 등이 있습니다.
> - 이 외에도 개발자가 커스텀한 객체가 내부 상태가 변화가 가능하다면 그것도 가변 객체이다.
- Immutable 객체는 불변 객체입니다. class의 인스턴스가 생성된 이후 내부 상태를 변경할 수 없는 객체입니다. 
> - 멀티 스레드 환경에서 안전하게 사용할 수 있다는 신뢰성이 보장됩니다.
> - 대표적인 불변 객체는 String이 있습니다.
> - 이 외에도 개발자가 커스텀 객체를 내부 상태가 변하지 않게 만든다면 그것도 불변 객체이다.

<br>

#### 직렬화와 역직렬화에 대해서 설명해주세요.
- 직렬화란 자바 시스템 내부에서 사용되는 객체나 데이터를 외부의 자바 시스템에서도 사용할 수 있게 바이트 형태로 데이터를 변환하는 기술입니다.
> - JVM의 메모리에서만 상주되어 있는 객체 데이터를 영속화가 필요할 때 사용됩니다. 시스템이 종료되어도 저장되는 장점이 있고 영속화된 데이터이므로 네트워크 전송이 가능합니다.
- 역직렬화는 바이트로 변환된 데이터를 다시 변환하는 기술입니다.

<br>

#### 자바의 동시성 이슈(공유자원 접근)에 대해 설명해주세요.
- 동시성 문제란 동일한 자원에 대해 여러 스레드가 동시에 접근하면서 발생하는 문제입니다.
- 동시성 문제가 발생하는 곳은 인스턴스 필드 (주로 싱글톤) 또는 static 같은 공용 필드에 접근할 때 발생합니다.
- 무조건 동시에 접근한다고 문제가 발생하는 것이 아니라 값을 변경할 때 문제가 생기며 읽기만 한다면 동시성 문제는 발생하지 않습니다.

#### 해결책
- ThreadLocal : 해당 스레드만 접근할 수 있는 개인 저장소 

```java
private ThreadLocal<String> threadStore = new ThreadLocal<>();
threadStore.set("hi"); //값 저장
threadStore.get(); //값 조회
threadStore.remove(); //값 제거
```

- 반드시 스레드를 사용하고 나서 값들을 제거해줘야 한다.
> - A 스레드 값 저장, 값 조회, 값 제거 > B 스레드 값 저장, 값 조회, 값 제거 

<br>

- syncronized : 기본 syncronized 키워드를 사용해서 여러 쓰레드가 동시에 해당 접근할 수 없도록 한다.
> - synchronized 가 선언된 블럭에는 동시에 하나의 스레드만 접근할 수 있다.
> - 해당 synchronized 를 남용하면 lock이 걸리는 쓰레드가 많아져 성능상 이슈가 발생할 수 있습니다. 


<br>

#### 추가적인 문제 상황

- 동시성 프로그램에서는 CPU와 RAM 중간에 위치한 CPU Cache Memory와 병렬성이라는 특징 때문에 가시성 문제, 원자성 문제가 발생할 수 있습니다.
- 가시성 문제 :  여러 개의 스레드가 사용됨에 따라 CPU Cache Memory와 RAM의 데이터가 서로 일치하지 않아 생기는 문제입니다. 
> - 하지만 여러 스레드가 공유 자원에 쓰기 연산을 할 경우 가시성을 보장했다고 해서 동시성을 보장하지는 않습니다.
- 해결책 : 가시성을 보장해야 하는 변수에 `volatile` 키워드를 붇여줘서 RAM에서 바로 읽도록 해야 합니다.

- 원자성 문제 : 여러 스레드가 공유자원에 동시에 쓰기 연산을 할 경우 잘못된 결과를 반환하는 것을 의미합니다. 
> - 한줄의 프로그램 statement(문장)가 컴파일러에 의해 기계어로 변경되면서, 이를 기계가 순차적으로 처리하기 위한 여러 개의 machine instruction이 만들어져 실행되기 때문에 일어나는 현상을 설명하는 용어.
> > - `i++` > 기존 변수 읽고(READ), 연산하고(MODIFY), 저장한다(WRITE) > 여러 스레드가 해당 로직을 처리하면서 꼬이는 문제
- 해결책 : `synchronized`, `atomic` 을 통해 원자성을 보장해야 합니다. 


<br>

#### 추가 학습할 것들   



<br>


Reference:
- [Backend-Interview-Question_ ksundong](https://github.com/ksundong/backend-interview-question)
- [신입 개발자 기술면접 질문 정리 - 자바](https://dev-coco.tistory.com/153)
