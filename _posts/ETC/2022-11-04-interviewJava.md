---
layout: post
title: 'Java Interview 대비'
subtitle: 'JVM, GC, OOP, API, JDBC'
date: 2022-11-04 12:00:00 +0900
categories: 'ETC'
background: '/img/posts/etc/git.png'

---

#### JVM의 구조와 Java의 실행방식을 설명해주세요

- JVM(Java Virtual Machine), 자바와 운영체제 사이의 중개자 역할을 한다. 가비지 컬렉터를 사용한 메모리 관리도 자동으로 수행하고, 스택 기반으로 동작한다.
> - 덕분에 운영체제에 구애받지 않고 프로그램을 실행할 수 있다.

- 실행방식
1 . 자바 컴파일러(javac)에 의해 자바 소스 파일(.java)이 바이트 코드(.class)로 변환된다.
2 . Class Loader를 통해 class 파일들을 JVM으로 로딩한다.
3 . 로딩된 class 파일들을 Excution engine을 통해 해석됩니다.
4 . 해석된 바이트 코드는 Runtime Data Areas에 배치되어 실질적인 수행이 이뤄집니다. 

- 구조 :
> - Class Loader : JVM 내로 클래스 파일을 로드, 링크를 통해 배치하는 작업을 수행하는 모듈, 런타임 시 동적으로 로드한다.
> - Garbage Collector : 힙 메모리 영역 참조되지 않은 객체 탐색 후 제거한다.
> - Execution Engine : Runtime Data Area에 배치된 바이트 코드를 명령어 단위로 읽어서 실행한다.
> > - 인터프리터 방식에서 JIT 컴파일러 방식으로 보완됨, JIT는 바이트 코드를 어셈블리어 같은 네이티브 코드로 바꿈으로써 실행이 빠르지만 변환 비용이 발생한다. 그러므로 JVM은 모든 코드를 JIT 컴파일러 방식으로 실행하지 않고 인터프리터 방식을 사용하다가 일정 기준이 넘어가면 JIT 컴파일러 방식으로 실행한다. 
> - Runtime Data Area : 자바 애플리케이션이 실행될 때 사용되는 데이터들을 적재하는 영역이다. (Method Area, Heap Area, Stack Area, PC Register, Native Method Stack)

<br>

#### JVM 메모리 구조에 대해 알고 있나요?
- JVM 메모리는 Runtime Data Area에 저장이 되며 메소드 영역, 힙 영역, 스택 영역, PC레지스터 영역, 네이티브 메소드 스택 영역으로 나누어집니다. 
> - 메소드 영역 : 모든 스레드가 공유하며 바이트코드로 변환된 것들을 저장합니다.(클래스, 인터페이스, 메소드, 필드, static 변수 등)
> - 힙 영역 : 모든 스레드가 공유하며, new 키워드로 생성된 객체와 배열이 저장되는 영역입니다. 클래스 영역에 로드된 클래스로 생성이 가능하고 GC가 참조되지 않는 메모리를 확인하고 제거합니다.
> - 스택 영역 : 메소드 호출 마다 스택 프레임(그 메소드를 위한 공간)이 생성됩니다. 메소드 안에서 사용되는 값(매개변수, 지역변수, 리턴 값 연산 시 일어나는 값)을 저장하고 메소드 수행이 끝나면 프레임별로 삭제합니다.
> - PC 레지스터 : 스레드가 시작될 때 생성되며, 스레드마다 하나씩 존재합니다. 스레드가 어떤 명령으로 실행해야 할 지에 대한 기록을 하는 부분으로 JVM 명령의 주소를 갖습니다.
> - 네이티브 메소드 스택 영역 : 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역입니다. 

<br>

### JIT(Just-In-Time) 컴파일러에 대해 알고 있나요?
- JVM의 Execution Engine에서 런타임 시 바이트 코드를 기계어로 변환하여 실행할 때 인터프리터를 이용합니다. 하지만 컴파일 언어에 비해 성능이 매우 떨어지게 됩니다. 이 때 사용되는 것이 JIT 컴파일러입니다. 
- 자주 실행되는 바이트 코드 영역을 런타임 중에 기계어로 컴파일하여 사용하는 것입니다. 


<br>

#### GC가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명해주세요.

- GC(Garbage Collector), 힙 영역에서 사용하지 않는 객체들을 제거하는 작업을 총징한다. 자바 언어는 개발자가 메모리를 직접 해제하는 언어가 아니기 때문이 이 작업은 꼭 필요하다. 
- GC의 동작 방식
> - Minor GC : young 영역, Major GC : old 영역
> - GC를 수행할 때는 GC 수행하는 스레드 외 모든 스레드는 정지한다.

<br>

#### 오버라이딩과 오버로딩이 무엇이며 어떤 차이가 있을까요?
- 오버라이딩 : 상위 클래스의 메소드를 재정의하는 것을 의미한다.(런타임 다형성)
> - 이름, 매개변수, 리턴타입이 같고, 메소드 내용이 달라야 한다.
- 오버로딩 : 같은 클래스 내 동일한 메소드 이름을 가지지만 매개변수의 타입, 갯수를 다르게 구현할 수 있는 것을 의미한다. (컴파일 다형성)
> - 메소드 이름이 같아야 하며, 매개변수 갯수, 타입이 달라야 한다.
> - 리턴타입만 다르면 성립이 되지 않고, 매개변수와 함께 달라져야 성립된다. 

<BR>

#### 객체지향 프로그래밍에 대해서 설명해주세요.

- 모든 데이터를 객체 취급하며, 처리 요청을 받은 객체는 객체 내부 기능을 사용해 요청을 처리합니다.
- 특징으로 캡슐화, 상속, 다형성, 추상화가 있습니다. 모듈 재사용성이 좋아 확장 및 유지보수가 용이합니다.
> - 캡슐화 : 클래스 내부 변수와 메소드를 하나로 패키징하는 것
> > - 정보 은닉 : 객체 내부 구현을 숨김으로써 객체가 반드시 정해진 메소드를 통해 상호작용하도록 유도하는 것
> > - 접근 제어자를 통해 구현
> > > - public : 다른 객체에서 해당 객체 인스턴스 생성하여 접근 가능
> > > - protected : 해당 객체를 상속받은 객체 내부에서 접근 가능
> > > - default : 동일한 패키지 내의 객체에서 인스턴스 생성하여 접근 가능
> > > - private : 선언된 객체 내부에서만 사용 가능

<BR>

#### try-with-resource에 대해서 설명해주세요.
- 자바7 이전에 try-catch-finally의 문제점으로 개발자가 close()를 통해 마지막에 자원을 해제시켜주는 것을 누락하거나, 자원 해제를 해줘도 중복 코드가 발생하기 때문에 가독성을 해치는 단점이 있었다.
- 자바 7 이후에 try(객체 선언)을 해주면 로직 처리 여부와 상관없이 JVM에서 자원을 해제시켜주는 기능이다.
- 자바 9 부터는 try 문 밖에서 객체를 선언하고 인스턴스 변수를 넣는 형태로 바뀌었다.  

<br>

#### API란?
- Application Progamming Interface의 줄임말, 컴퓨터와 컴퓨터 프로그램 사이의 연결
- 애플리케이션 소프트웨어를 빌드하고 통합하기 위한 정의 및 프로토콜 세트
- 당사자들 간 계약을 나타내는 문서를 갖춘 계약으로 비유되기도 한다. 한쪽 당사자가 특정한 방식으로 구성된 원격 요청을 보내면 다른 쪽 당사자의 소프트웨어가 이에 응답하는 방식이기 때문이다. 

<br>

#### JDBC API이란
-  Java DataBase Connectivity의 줄임말, 자바 프로그램  내에서 DB 상관없이 DB와 관련된 작업을 처리해주는 API이다.

<br>

#### SOLID(객체지향 5대원칙)에 대해서 설명해주세요.
- SRP(Single Responsibility Principle, 단일 책임 원칙) : 한 클래스는 하나의 책임만 가져야 합니다. 즉 클래스는 그 책임읠 완전히 캡슐화해야 함을 말한다. 
- OCP(Open Closed Principle, 개방 폐쇄 원칙) : 확장에는 열려 있어야 하나 변경에는 닫혀 있어야 합니다. 이를 적용하기 위핸 중요 메커니즘은 추상화와 다형성입니다. 
- LSP(Liskov Substitution Principle, 리스코프 치환 법칙) : 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 합니다. 상위 타입을 상속해서 재정의했을 대 프로그램에 에러가 없어야 합니다.
- DIP(Dependency Inversion Principle, 의존관계 역전 원칙) : 추상적인 것은 구체적인 것에 의존하지 않고, 변화하기 쉬운 것에 의존하면 안된다는 것입니다. 구체적으로는 구현 클래스에 의존하지 말고 인터페이스에 의존해야 하는 원칙입니다. 
> - DIP를 따르는 인기 있는 방법은 DI(의존성 주입)을 활용하는 것이다.
- ISP(Interface Segregation Principle, 인터페이스 분리 원칙) : 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안되는 원칙입니다. 범용 인터페이스 보다는 여러 개의 인터페이스로 분리해야합니다. 
> - SRP, ISP는 같은 문제에 대한 두 가치 다른 해결책이라고 볼 수 있습니다. 가능한 최소한의 인터페이스를 사용하도록 하여 단일 책임을 강조한다고 볼 수 있습니다.
> - 일반적으로 ISP보다 SRP 할 것을 권장합니다.

<br>
#### 클래스, 인스턴스,객체는 무엇인가요?
- 클래스 :  객체를 정의하는 틀, 설계도와 같은 의미로 사용됩니다.(메소드 영역에 저장)
- 인스턴스 : 클래스를 이용해 생성된 객체를 인스턴스라 합니다. (힙 영역에 저장)
- 객체 : 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있고 다른 것과 식별 가능한 것을 의미합니다.  


<br>
#### 자바의 원시타입들은 무엇이 있으며 각각 몇 바이트를 차지하나요?
- 정수형 byte : 1, short : 2, int : 4, long : 8
- 실수형 float : 4, double : 8
- 문자형 char : 2
- 논리형 boolean : 1

<br>

#### 컬렉션 프레임워크에 대해서 설명해주세요.
- 널리 알려져 있는 자료구조를 바탕으로 객체, 데이터들을 효율적으로 관리할 수 있는 자료구조들이 있는 라이브러리를 말합니다.

<br>

#### 제네릭에 대해서 설명해주세요.
- 제너릭은 자바의 타입 안정성을 맡고 있습니다. 컴파일 과정에서 타입체크를 해주므로 객체의 타입 안정성을 높이고 형변환의 번거로움을 줄여줍니다.

<br>

#### 어노테이션에 대해서 설명해주세요.
- 어노테이션은 인터페이스를 기반으로 한 문법으로 주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나 기능을 주입할 수 있습니다. 

<br>

#### 인터페이스와 추상클래스의 차이점에 대해 설명해주세요.
- 인터페이스 
> -  모든 메소드가 추상메소드로 이루어져 있는 것을 말합니다.
> - 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용합니다. 
> - 다중 상속이 가능하고 인터페이스를 상속하는 집합 간에는 연관관계가 없습니다.
- 추상클래스 
> - 클래스 내 하나의 이상의 추상 메소드(abstract)를 포함한 경우를 말합니다. 
> - 객체의 추상적인 상위 개념으로 공통된 개념을 표현할 때 사용합니다.
> - 단일 상속만 가능하고, 추상 클래스를 상속하는 집합 간에는 연관관계가 있습니다.

<br>

#### 정적(static)이란 무엇인가요?
- static은 클래스 멤버라고 합니다. JVM의 클래스 로더가 클래스를 로딩해서 Runtime Data Area에 저장할 때 클래스별로 관리됩니다. 
- static 키워드를 통해 생성된 정적멤버들은 Permanent Generation(자바7) 또는 Metaspace(자바8부터)에 저장되고 해당 메모리는 모든 객체가 공유하게 됩니다.
- 하지만 GC 관리 밖에 존재하기 때문에 프로그램 종료까지 존재하게 됩니다. 남발하게 되면 시스템 성능에 문제가 될 수 있습니다. 

<br>

#### 접근 제어자의 종류와 이에 대해 설명해주세요.
- private : 해당 클래스 내에서만 접근 가능
- default : 해당 패키지만 접근 가능
- protected : 상속한 클래스까지 접근 가능
- public : 전체 영역에서 접근 가능

<br>

#### Java8에서 추가된 기능에 대해서 설명해주세요.
- Java8부터 Lambda식, Stream API, Optional, 날짜 시간 API, StringJoiner 등이 추가되었습니다. 또한 Static 저장하는 공간이 Permanent Generation `->` Metaspace로 바뀌었습니다. 

#### Java11에서 추가된 기능에 대해서 설명해주세요.
- Java11부터 String 클래스의 메소드, 컬렉션 인터페이스에서 toArray()  메소드를 오버로딩하는 메소드, javac 컴파일 없이 바로 실행 가능, GC 버전 G1 GC로 변경되었습니다. 

<br>

#### 동일성(identity)와 동등성(equality)에 대해 설명해주세요. (equals(), ==)
- 동일성은 참조하는 객체가 같은 것을 의미하고 동등성은 객체의 값이 같은 것을 의미합니다. 
- 기본적으로 equals()는 동일성 비교를 합니다. 따라서 원한다면 메소드를 오버라이딩해서 동등성을 판단할 때 사용하면 됩니다. 


<br>

#### 추가 학습할 것들

원시타입과 참조타입의 차이에 대해 설명해주세요.

String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.

Checked Exception과 Unchecked Exception에 대해 설명해주세요. 스프링 트랜잭션 추상화에서 rollback 대상은 무엇일까요?


강한 결합과 느슨한 결합이 무엇인지 설명해주세요.

직렬화와 역직렬화에 대해서 설명해주세요.

자바의 동시성 이슈(공유자원 접근)에 대해 설명해주세요.

Mutable 객체와 Immutable 객체의 차이점에 대해 설명해주세요.

자바에서 null을 안전하게 다루는 방법에 대해 설명해주세요.



<br>


Reference:
- [Backend-Interview-Question_ ksundong](https://github.com/ksundong/backend-interview-question)
- [신입 개발자 기술면접 질문 정리 - 자바](https://dev-coco.tistory.com/153)
