I"k<h4 id="jvm의-구조와-java의-실행방식을-설명해주세요">JVM의 구조와 Java의 실행방식을 설명해주세요</h4>

<ul>
  <li>JVM(Java Virtual Machine), 자바와 운영체제 사이의 중개자 역할을 한다. 가비지 컬렉터를 사용한 메모리 관리도 자동으로 수행하고, 스택 기반으로 동작한다.
    <blockquote>
      <ul>
        <li>덕분에 운영체제에 구애받지 않고 프로그램을 실행할 수 있다.</li>
      </ul>
    </blockquote>
  </li>
  <li>실행방식
    <ol>
      <li>자바 컴파일러(javac)에 의해 자바 소스 파일(.java)이 바이트 코드(.class)로 변환된다.</li>
      <li>Class Loader를 통해 class 파일들을 JVM으로 로딩한다.</li>
      <li>로딩된 class 파일들을 Excution engine을 통해 해석됩니다.</li>
      <li>해석된 바이트 코드는 Runtime Data Areas에 배치되어 실질적인 수행이 이뤄집니다.</li>
    </ol>
  </li>
  <li>구조 :
    <blockquote>
      <ul>
        <li>Class Loader : JVM 내로 클래스 파일을 로드, 링크를 통해 배치하는 작업을 수행하는 모듈, 런타임 시 동적으로 로드한다.</li>
        <li>Garbage Collector : 힙 메모리 영역 참조되지 않은 객체 탐색 후 제거한다.</li>
        <li>Execution Engine : Runtime Data Area에 배치된 바이트 코드를 명령어 단위로 읽어서 실행한다.
          <blockquote>
            <ul>
              <li>인터프리터 방식에서 JIT 컴파일러 방식으로 보완되었다.
                <blockquote>
                  <ul>
                    <li>JIT 컴파일러는 반복되는 코드를 발견하면 바이트 코드를 어셈블리어 같은 네이티브 코드로 바꿉니다. 실행이 빠르지만 변환 비용이 비교적 크게 발생한다.</li>
                    <li>그러므로 JVM은 모든 코드를 JIT 컴파일러 방식으로 실행하지 않고 인터프리터 방식을 사용하다가 일정 기준이 넘어가면 JIT 컴파일러 방식으로 실행한다.</li>
                  </ul>
                </blockquote>
              </li>
            </ul>
          </blockquote>
        </li>
        <li>Runtime Data Area : 자바 애플리케이션이 실행될 때 사용되는 데이터들을 적재하는 영역이다. (Method Area, Heap Area, Stack Area, PC Register, Native Method Stack)</li>
      </ul>
    </blockquote>
  </li>
</ul>

<p><br /></p>

<h4 id="jvm-메모리-구조에-대해-알고-있나요">JVM 메모리 구조에 대해 알고 있나요?</h4>
<ul>
  <li>JVM 메모리는 Runtime Data Area에 저장이 되며 메소드 영역, 힙 영역, 스택 영역, PC레지스터 영역, 네이티브 메소드 스택 영역으로 나누어집니다.
    <blockquote>
      <ul>
        <li>메소드 영역 : 모든 스레드가 공유하며 바이트코드로 변환된 것들을 저장합니다.(클래스, 인터페이스, 메소드, 필드, static 변수 등)</li>
        <li>힙 영역 : 모든 스레드가 공유하며, new 키워드로 생성된 객체와 배열이 저장되는 영역입니다. 클래스 영역에 로드된 클래스로 생성이 가능하고 GC가 참조되지 않는 메모리를 확인하고 제거합니다.</li>
        <li>스택 영역 : 메소드 호출 마다 스택 프레임(그 메소드를 위한 공간)이 생성됩니다. 메소드 안에서 사용되는 값(매개변수, 지역변수, 리턴 값 연산 시 일어나는 값)을 저장하고 메소드 수행이 끝나면 프레임별로 삭제합니다.</li>
        <li>PC 레지스터 : 스레드가 시작될 때 생성되며, 스레드마다 하나씩 존재합니다. 스레드가 어떤 명령으로 실행해야 할 지에 대한 기록을 하는 부분으로 JVM 명령의 주소를 갖습니다.</li>
        <li>네이티브 메소드 스택 영역 : 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역입니다.</li>
      </ul>
    </blockquote>
  </li>
</ul>

<p><br /></p>

<h3 id="jitjust-in-time-컴파일러에-대해-알고-있나요">JIT(Just-In-Time) 컴파일러에 대해 알고 있나요?</h3>
<ul>
  <li>JVM의 Execution Engine에서 런타임 시 바이트 코드를 기계어로 변환하여 실행할 때 인터프리터를 이용합니다. 하지만 컴파일 언어에 비해 성능이 매우 떨어지게 됩니다. 이 때 사용되는 것이 JIT 컴파일러입니다.</li>
  <li>자주 실행되는 바이트 코드 영역을 런타임 중에 기계어로 컴파일하여 사용하는 것입니다.</li>
</ul>

<p><br /></p>

<h4 id="gc가-무엇인지-필요한-이유는-무엇인지-동작방식에-대해-설명해주세요">GC가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명해주세요.</h4>

<ul>
  <li>GC(Garbage Collection), 힙 영역에서 사용하지 않는 객체들을 제거하는 작업을 총징한다. 자바 언어는 개발자가 메모리를 직접 해제하는 언어가 아니기 때문이 이 작업은 꼭 필요하다.</li>
  <li>GC의 영역
    <blockquote>
      <ul>
        <li>Minor GC : young 영역, 새롭게 생성된 객체가 할당 되는 영역, 먾은 객체가 Young 영역에 생성되었다 사라집니다.</li>
        <li>Major GC : old 영역, 특정 횟수 이상을 살아남은 참조 변수가 살아있는 곳입니다.</li>
      </ul>
    </blockquote>
  </li>
  <li>GC의 동작 방식
    <blockquote>
      <ul>
        <li>Stop The World : GC를 수행하기 위해 JVM이 어플리케이션의  실행을 멈추는 작업을 말합니다. GC를 실행하는 스레드를 제외한 모든 스레드들의 작업이 중단되고 GC가 완료되면 작업이 재개됩니다.
          <blockquote>
            <ul>
              <li>스레드의  작업이 중단되면 어플리케이션이 멈추기 때문에 GC 성능 튜닝을 한다고 하면 이 부분의 시간을 줄이는 작업을 말합니다.</li>
            </ul>
          </blockquote>
        </li>
        <li>Mark And Sweep : 모든 작업이 중단되면 GC는 스택의 모든 변수 또는 Reachable 객체(어디선가 사용하고 있는 객체, Unreachable : 아무도 사용하지 않고 자리만 차지하고 있는 객체)를 스캔하면서 각각 어떤 객체를 참조하고 있는지 탐색하게 됩니다. 그리고 사용되고 있는 메모리를 식별하고 사용되지 않는 객체를 제거합니다.</li>
      </ul>
    </blockquote>
  </li>
  <li><a href="https://hajoung56.tistory.com/43">[JAVA] Garbage Collection의 개념과 동작 원리</a></li>
</ul>

<p><br /></p>

<h4 id="오버라이딩과-오버로딩이-무엇이며-어떤-차이가-있을까요">오버라이딩과 오버로딩이 무엇이며 어떤 차이가 있을까요?</h4>
<ul>
  <li>오버라이딩 : 상위 클래스의 메소드를 재정의하는 것을 의미한다.(런타임 다형성)
    <blockquote>
      <ul>
        <li>이름, 매개변수, 리턴타입이 같고, 메소드 내용이 달라야 한다.</li>
      </ul>
    </blockquote>
  </li>
  <li>오버로딩 : 같은 클래스 내 동일한 메소드 이름을 가지지만 매개변수의 타입, 갯수를 다르게 구현할 수 있는 것을 의미한다. (컴파일 다형성)
    <blockquote>
      <ul>
        <li>메소드 이름이 같아야 하며, 매개변수 갯수, 타입이 달라야 한다.</li>
        <li>리턴타입만 다르면 성립이 되지 않고, 매개변수와 함께 달라져야 성립된다.</li>
      </ul>
    </blockquote>
  </li>
</ul>

<p><br /></p>

<h4 id="객체지향-프로그래밍에-대해서-설명해주세요">객체지향 프로그래밍에 대해서 설명해주세요.</h4>

<ul>
  <li>모든 데이터를 객체 취급하며, 처리 요청을 받은 객체는 객체 내부 기능을 사용해 요청을 처리합니다.</li>
  <li>특징으로 캡슐화, 상속, 다형성, 추상화가 있습니다. 모듈 재사용성이 좋아 확장 및 유지보수가 용이합니다.
    <blockquote>
      <ul>
        <li>캡슐화 : 클래스 내부 변수와 메소드를 하나로 패키징하는 것
          <blockquote>
            <ul>
              <li>정보 은닉 : 객체 내부 구현을 숨김으로써 객체가 반드시 정해진 메소드를 통해 상호작용하도록 유도하는 것</li>
              <li>접근 제어자를 통해 구현
                <blockquote>
                  <ul>
                    <li>public : 다른 객체에서 해당 객체 인스턴스 생성하여 접근 가능</li>
                    <li>protected : 해당 객체를 상속받은 객체 내부에서 접근 가능</li>
                    <li>default : 동일한 패키지 내의 객체에서 인스턴스 생성하여 접근 가능</li>
                    <li>private : 선언된 객체 내부에서만 사용 가능</li>
                  </ul>
                </blockquote>
              </li>
            </ul>
          </blockquote>
        </li>
      </ul>
    </blockquote>
  </li>
</ul>

<p><br /></p>

<h4 id="try-with-resource에-대해서-설명해주세요">try-with-resource에 대해서 설명해주세요.</h4>
<ul>
  <li>자바7 이전에 try-catch-finally의 문제점으로 개발자가 close()를 통해 마지막에 자원을 해제시켜주는 것을 누락하거나, 자원 해제를 해줘도 중복 코드가 발생하기 때문에 가독성을 해치는 단점이 있었다.</li>
  <li>자바 7 이후에 try(객체 선언)을 해주면 로직 처리 여부와 상관없이 JVM에서 자원을 해제시켜주는 기능이다.</li>
  <li>자바 9 부터는 try 문 밖에서 객체를 선언하고 인스턴스 변수를 넣는 형태로 바뀌었다.</li>
</ul>

<p><br /></p>

<h4 id="api란">API란?</h4>
<ul>
  <li>Application Progamming Interface의 줄임말, 컴퓨터와 컴퓨터 프로그램 사이의 연결</li>
  <li>애플리케이션 소프트웨어를 빌드하고 통합하기 위한 정의 및 프로토콜 세트</li>
  <li>당사자들 간 계약을 나타내는 문서를 갖춘 계약으로 비유되기도 한다. 한쪽 당사자가 특정한 방식으로 구성된 원격 요청을 보내면 다른 쪽 당사자의 소프트웨어가 이에 응답하는 방식이기 때문이다.</li>
</ul>

<p><br /></p>

<h4 id="jdbc-api이란">JDBC API이란</h4>
<ul>
  <li>Java DataBase Connectivity의 줄임말, 자바 프로그램  내에서 DB 상관없이 DB와 관련된 작업을 처리해주는 API이다.</li>
</ul>

<p><br /></p>

<h4 id="solid객체지향-5대원칙에-대해서-설명해주세요">SOLID(객체지향 5대원칙)에 대해서 설명해주세요.</h4>
<ul>
  <li>SRP(Single Responsibility Principle, 단일 책임 원칙) : 한 클래스는 하나의 책임만 가져야 합니다. 즉 클래스는 그 책임읠 완전히 캡슐화해야 함을 말한다.</li>
  <li>OCP(Open Closed Principle, 개방 폐쇄 원칙) : 확장에는 열려 있어야 하나 변경에는 닫혀 있어야 합니다. 이를 적용하기 위핸 중요 메커니즘은 추상화와 다형성입니다.</li>
  <li>LSP(Liskov Substitution Principle, 리스코프 치환 법칙) : 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 합니다. 상위 타입을 상속해서 재정의했을 대 프로그램에 에러가 없어야 합니다.</li>
  <li>DIP(Dependency Inversion Principle, 의존관계 역전 원칙) : 추상적인 것은 구체적인 것에 의존하지 않고, 변화하기 쉬운 것에 의존하면 안된다는 것입니다. 구체적으로는 구현 클래스에 의존하지 말고 인터페이스에 의존해야 하는 원칙입니다.
    <blockquote>
      <ul>
        <li>DIP를 따르는 인기 있는 방법은 DI(의존성 주입)을 활용하는 것이다.</li>
      </ul>
    </blockquote>
  </li>
  <li>ISP(Interface Segregation Principle, 인터페이스 분리 원칙) : 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안되는 원칙입니다. 범용 인터페이스 보다는 여러 개의 인터페이스로 분리해야합니다.
    <blockquote>
      <ul>
        <li>SRP, ISP는 같은 문제에 대한 두 가치 다른 해결책이라고 볼 수 있습니다. 가능한 최소한의 인터페이스를 사용하도록 하여 단일 책임을 강조한다고 볼 수 있습니다.</li>
        <li>일반적으로 ISP보다 SRP 할 것을 권장합니다.</li>
      </ul>
    </blockquote>
  </li>
</ul>

<p><br /></p>
<h4 id="클래스-인스턴스객체는-무엇인가요">클래스, 인스턴스,객체는 무엇인가요?</h4>
<ul>
  <li>클래스 :  객체를 정의하는 틀, 설계도와 같은 의미로 사용됩니다.(메소드 영역에 저장)</li>
  <li>인스턴스 : 클래스를 이용해 생성된 객체를 인스턴스라 합니다. (힙 영역에 저장)</li>
  <li>객체 : 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있고 다른 것과 식별 가능한 것을 의미합니다.</li>
</ul>

<p><br /></p>
<h4 id="자바의-원시타입들은-무엇이-있으며-각각-몇-바이트를-차지하나요">자바의 원시타입들은 무엇이 있으며 각각 몇 바이트를 차지하나요?</h4>
<ul>
  <li>정수형 byte : 1, short : 2, int : 4, long : 8</li>
  <li>실수형 float : 4, double : 8</li>
  <li>문자형 char : 2</li>
  <li>논리형 boolean : 1</li>
</ul>

<p><br /></p>

<h4 id="컬렉션-프레임워크에-대해서-설명해주세요">컬렉션 프레임워크에 대해서 설명해주세요.</h4>
<ul>
  <li>널리 알려져 있는 자료구조를 바탕으로 객체, 데이터들을 효율적으로 관리할 수 있는 자료구조들이 있는 라이브러리를 말합니다.</li>
</ul>

<h4 id="stream이란">Stream이란?</h4>
<ul>
  <li>데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소입니다.</li>
  <li>Stream의 경우 반복을 알아서 처리하고 결과값을 어딘가에 저장하는 내부반복을 사용합니다.</li>
  <li>덕분에 직접 반복문을 적을 필요가 없으며, 병렬성 처리에 이점이 있습니다.
    <blockquote>
      <ul>
        <li>내부반복을 이용하기 때문에 스레드 공유자원에 대한 동기화를 관리해줄 필요가 없습니다.</li>
      </ul>
    </blockquote>
  </li>
  <li>예시 :  filter, distinct, map, reduce 등</li>
</ul>

<p><br /></p>

<h4 id="제네릭에-대해서-설명해주세요">제네릭에 대해서 설명해주세요.</h4>
<ul>
  <li>제너릭은 자바의 타입 안정성을 맡고 있습니다. 컴파일 과정에서 타입체크를 해주므로 객체의 타입 안정성을 높이고 형변환의 번거로움을 줄여줍니다.</li>
</ul>

<p><br /></p>

<h4 id="어노테이션에-대해서-설명해주세요">어노테이션에 대해서 설명해주세요.</h4>
<ul>
  <li>어노테이션은 인터페이스를 기반으로 한 문법으로 주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나 기능을 주입할 수 있습니다.</li>
</ul>

<p><br /></p>

<h4 id="인터페이스와-추상클래스의-차이점에-대해-설명해주세요">인터페이스와 추상클래스의 차이점에 대해 설명해주세요.</h4>
<ul>
  <li>인터페이스
    <blockquote>
      <ul>
        <li>모든 메소드가 추상메소드로 이루어져 있는 것을 말합니다.</li>
        <li>구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용합니다.</li>
        <li>다중 상속이 가능하고 인터페이스를 상속하는 집합 간에는 연관관계가 없습니다.</li>
      </ul>
    </blockquote>
  </li>
  <li>추상클래스
    <blockquote>
      <ul>
        <li>클래스 내 하나의 이상의 추상 메소드(abstract)를 포함한 경우를 말합니다.</li>
        <li>객체의 추상적인 상위 개념으로 공통된 개념을 표현할 때 사용합니다.</li>
        <li>단일 상속만 가능하고, 추상 클래스를 상속하는 집합 간에는 연관관계가 있습니다.</li>
      </ul>
    </blockquote>
  </li>
</ul>

<p><br /></p>

<h4 id="정적static이란-무엇인가요">정적(static)이란 무엇인가요?</h4>
<ul>
  <li>static은 클래스 멤버라고 합니다. JVM의 클래스 로더가 클래스를 로딩해서 Runtime Data Area의 메소드 영역에 저장할 때 클래스별로 관리됩니다.</li>
  <li>static 키워드를 통해 생성된 정적멤버들은 Permanent Generation(자바7) 또는 Metaspace(자바8부터)에 저장되고 해당 메모리는 모든 객체가 공유하게 됩니다.</li>
  <li>하지만 GC 관리 밖에 존재하기 때문에 프로그램 종료까지 존재하게 됩니다. 남발하게 되면 시스템 성능에 문제가 될 수 있습니다.</li>
</ul>

<p><br /></p>

<h4 id="접근-제어자의-종류와-이에-대해-설명해주세요">접근 제어자의 종류와 이에 대해 설명해주세요.</h4>
<ul>
  <li>private : 해당 클래스 내에서만 접근 가능</li>
  <li>default : 같은 패키지 내에서만 접근 가능</li>
  <li>protected : 상속한 클래스까지 접근 가능, 다른 패키지여도 자식 클래스면 접근 가능하다.</li>
  <li>public : 전체 영역에서 접근 가능</li>
</ul>

<p><br /></p>

<h4 id="final이-클래스-메소드-변수에-붙었을-때-차이를-알고-있나요">final이 클래스, 메소드, 변수에 붙었을 때 차이를 알고 있나요?</h4>
<ul>
  <li>final + 클래스 : 상속이 불가하다.</li>
  <li>final + 메소드 : 오버라이딩이 불가하다.</li>
  <li>final + 변수 : 상수화되어 수정이 불가하다.</li>
</ul>

<p><br /></p>

<h4 id="java8에서-추가된-기능에-대해서-설명해주세요">Java8에서 추가된 기능에 대해서 설명해주세요.</h4>
<ul>
  <li>Java8부터 Lambda식, Stream API, Optional, 날짜 시간 API, StringJoiner 등이 추가되었습니다. 또한 Permanent Generation이 사라지고 Metaspace 영역(Native 메모리 영역에 속함)이 생겼습니다.
    <blockquote>
      <ul>
        <li>Permanent Generation은 Class, Method Code가 저장되는 영역이며 힙 영역에 속했다.</li>
        <li>Classloader가 현재까지 로드한  Class의 Metadata가 저장되는 공간이며 Native 메모리 영역에 속한다. 또한 크기 제한이 없다.
          <blockquote>
            <ul>
              <li>Metadata : 데이터에 대한 데이터를 의미한다. 다른 데이터를 설명하기 위한 데이터를 말하고 구조화된 정보를 분석, 분류하고 정보를 추가하기 위해 그 데이터에 뒤를 따라 가는 정보를 말한다.</li>
            </ul>
          </blockquote>
        </li>
      </ul>
    </blockquote>
  </li>
</ul>

<h4 id="java11에서-추가된-기능에-대해서-설명해주세요">Java11에서 추가된 기능에 대해서 설명해주세요.</h4>
<ul>
  <li>Java11부터 String 클래스의 메소드, 컬렉션 인터페이스에서 toArray()  메소드를 오버로딩하는 메소드, javac 컴파일 없이 바로 실행 가능, GC 버전 G1 GC로 변경되었습니다.</li>
</ul>

<p><br /></p>

<h4 id="동일성identity와-동등성equality에-대해-설명해주세요-equals-">동일성(identity)와 동등성(equality)에 대해 설명해주세요. (equals(), ==)</h4>
<ul>
  <li>동일성은 참조하는 객체가 같은 것을 의미하고 동등성은 객체의 값이 같은 것을 의미합니다.</li>
  <li>기본적으로 equals()는 동일성 비교를 합니다. 따라서 원한다면 메소드를 오버라이딩해서 동등성을 판단할 때 사용하면 됩니다.</li>
</ul>

<p><br /></p>

<h4 id="원시타입과-참조타입의-차이에-대해-설명해주세요">원시타입과 참조타입의 차이에 대해 설명해주세요.</h4>
<ul>
  <li>원시타입은 정수, 실수, 논리를 직접 저장하는 8개의 타입을 말한다. 변수마다 사용할 수 있는 값의 범위가 있고 기본값이 존재한다. 원시타입은 스택에 저장이 된다.
    <blockquote>
      <ul>
        <li>범위를 넘어가면 오버플로우 발생</li>
      </ul>
    </blockquote>
  </li>
  <li>참조타입은 원시타입을 제외한 모두를 일컫는다. 번지를 통해 객체를 참조한다는 뜻이다. Object 클래스를 상속하거나, Object 클래스입니다. 참조 타입은 힙 영역에 저장이 된다.</li>
</ul>

<p><br /></p>

<h4 id="checked-exception과-unchecked-exception에-대해-설명해주세요-스프링-트랜잭션-추상화에서-rollback-대상은-무엇일까요">Checked Exception과 Unchecked Exception에 대해 설명해주세요. 스프링 트랜잭션 추상화에서 rollback 대상은 무엇일까요?</h4>
<ul>
  <li>둘의 차이는 RuntimeException을  상속하는가의 여부에 따라 다릅니다. RuntimeException을 상속하면 UncheckedException입니다.</li>
  <li>스프링 트랜잭션 추상화 rollback 대상은 UncheckedException입니다.</li>
  <li>CheckedException은 컴파일 실행이 안되기 때문에 예외 처리를 꼭 해줘야 한다.</li>
</ul>

<p><br /></p>
<h4 id="자바에서-null을-안전하게-다루는-방법에-대해-설명해주세요">자바에서 null을 안전하게 다루는 방법에 대해 설명해주세요.</h4>
<ul>
  <li>Spring Assert를 이용해 null 방어하는 방법</li>
  <li>자바8부터 추가된 Optional 객체로 감싸는 방법</li>
  <li>롬복의 @NonNull을 사용하는 방법</li>
  <li>엔티티 필드를 검증하기 위해  @NotNull을 사용하는 방법
    <blockquote>
      <ul>
        <li>@Column(nullable = false)은 JPA가 만든 엔티티 필드 값이 Null로 채워져서 정상적으로 처리되다가 DB에 도착한 순간 NOT NULL 옵션이 발생하여 예외처리가 된다.</li>
        <li>@NotNull은 필드값이 Null로 채워지는 순간 예외가 처리된다. @NotNull이 더 빠른 단계에서 예외를 검출한다.</li>
        <li><a href="https://hyeon9mak.github.io/not-null-vs-column-nullable-false/">@NotNull vs @Column(nullable = false)_현구막</a></li>
      </ul>
    </blockquote>
  </li>
  <li>예외 처리를 다른 곳에서 한다면 @NotNull(message=”~~”) 를 이용하여 null값이 오면 메세지로 리턴해주는 방법</li>
</ul>

<p><br /></p>

<h4 id="string-stringbuilder-stringbuffer-각각의-차이에-대해-설명해주세요">String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.</h4>
<ul>
  <li>String은 불변입니다. 그래서 StringBuilder, StringBuffer를 사용하는 가변 타입입니다.</li>
  <li>StringBuilder는 Thread-safe하지 않습니다. 따라서 멀티 스레드 환경일 때는 StringBuffer를 사용합니다.</li>
</ul>

<p><br /></p>

<h4 id="강한-결합과-느슨한-결합이-무엇인지-설명해주세요">강한 결합과 느슨한 결합이 무엇인지 설명해주세요.</h4>
<ul>
  <li>결합도는 의존성의 정도를 나타냅니다. 다른 모듈에 대해 얼마나 많은 정보를 알고 있는지에 대한 척도입니다.</li>
  <li>어떤 모듈이 다른 모듈에 대해 필요한 정보(인터페이스로 추상화된 고수준의 정책)만 알고 있다면 두 모듈은 낮은 결합도를 가진다고 합니다.</li>
  <li>객체지향 관점에서 결합도는 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계를 유지하고 있는지를 나타냅니다. 그러므로 강한 결합도는 지양해야 하고 적절한 결합도를 유지할 수 있도록 고민하고 설계해야 합니다.</li>
</ul>

<p><br /></p>

<h4 id="mutable-객체와-immutable-객체의-차이점에-대해-설명해주세요">Mutable 객체와 Immutable 객체의 차이점에 대해 설명해주세요.</h4>
<ul>
  <li>Mutable 객체는 가변 객체입니다. class의 인스턴스가 생성된 이후 내부 상태가 변경 가능한 객체입니다.
    <blockquote>
      <ul>
        <li>멀티 스레드 환경에서 사용하려면 별도의 동기화 처리가 필요합니다.</li>
        <li>대표적으로 ArrayList, HashMap, StringBuilder, StringBuffer(멀티스레드 환경에서 사용) 등이 있습니다.</li>
        <li>이 외에도 개발자가 커스텀한 객체가 내부 상태가 변화가 가능하다면 그것도 가변 객체이다.</li>
      </ul>
    </blockquote>
  </li>
  <li>Immutable 객체는 불변 객체입니다. class의 인스턴스가 생성된 이후 내부 상태를 변경할 수 없는 객체입니다.
    <blockquote>
      <ul>
        <li>멀티 스레드 환경에서 안전하게 사용할 수 있다는 신뢰성이 보장됩니다.</li>
        <li>대표적인 불변 객체는 String이 있습니다.</li>
        <li>이 외에도 개발자가 커스텀 객체를 내부 상태가 변하지 않게 만든다면 그것도 불변 객체이다.</li>
      </ul>
    </blockquote>
  </li>
</ul>

<p><br /></p>

<h4 id="직렬화와-역직렬화에-대해서-설명해주세요">직렬화와 역직렬화에 대해서 설명해주세요.</h4>
<ul>
  <li>직렬화란 자바 시스템 내부에서 사용되는 객체나 데이터를 외부의 자바 시스템에서도 사용할 수 있게 바이트 형태로 데이터를 변환하는 기술입니다.
    <blockquote>
      <ul>
        <li>JVM의 메모리에서만 상주되어 있는 객체 데이터를 영속화가 필요할 때 사용됩니다. 시스템이 종료되어도 저장되는 장점이 있고 영속화된 데이터이므로 네트워크 전송이 가능합니다.</li>
      </ul>
    </blockquote>
  </li>
  <li>역직렬화는 바이트로 변환된 데이터를 다시 변환하는 기술입니다.</li>
</ul>

<p><br /></p>

<h4 id="자바의-동시성-이슈공유자원-접근에-대해-설명해주세요">자바의 동시성 이슈(공유자원 접근)에 대해 설명해주세요.</h4>
<ul>
  <li>동시성 프로그램에서는 CPU와 RAM 중간에 위치한 CPU Cache Memory와 병렬성이라는 특징 때문에 가시성 문제, 원자성 문제가 발생할 수 있습니다.
    <blockquote>
      <ul>
        <li>가시성 문제 :  여러 개의 스레드가 사용됨에 따라 CPU Cache Memory와 RAM의 데이터가 서로 일치하지 않아 생기는 문제입니다. 가시성을 보장해야 하는 변수에 volatile 키워드를 붇여줘서 RAM에서 바로 읽도록 해야 합니다.
          <blockquote>
            <ul>
              <li>하지만 여러 스레드가 공유 자원에 쓰기 연산을 할 경우 가시성을 보장했다고 해서 동시성을 보장하지는 않습니다.</li>
            </ul>
          </blockquote>
        </li>
        <li>원자성 문제 : 여러 스레드가 공유자원에 동시에 쓰기 연산을 할 경우 잘못된 결과를 반환하는 것을 의미합니다. synchronized, atomic 을 통해 원자성을 보장해야 합니다.</li>
      </ul>
    </blockquote>
  </li>
</ul>

<p><br /></p>

<h4 id="추가-학습할-것들">추가 학습할 것들</h4>

<p><br /></p>

<p>Reference:</p>
<ul>
  <li><a href="https://github.com/ksundong/backend-interview-question">Backend-Interview-Question_ ksundong</a></li>
  <li><a href="https://dev-coco.tistory.com/153">신입 개발자 기술면접 질문 정리 - 자바</a></li>
</ul>
:ET