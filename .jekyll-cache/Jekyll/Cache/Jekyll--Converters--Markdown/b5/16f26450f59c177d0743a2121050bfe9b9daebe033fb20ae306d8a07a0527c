I"?<h3 id="aopaspect-oriented-programming-관점-지향-프로그래밍">AOP(Aspect Oriented Programming, 관점 지향 프로그래밍)</h3>

<ul>
  <li>AOP는 어디에 관점을 두는가? 로 시작한다.</li>
  <li>쉽게 말하면 로직을 공통된 로직과 핵심 로직을 나누어 사용하겠다는 것이다.</li>
  <li>중요한 것은 관심 분리(Separation of Concerns)이다.
    <blockquote>
      <ul>
        <li>
          <dl>
            <dt>횡단 관심 (Crosscutting Concerns)</dt>
            <dd>모든 메소드에 들어있는 공통된 로직을 의미한다.</dd>
          </dl>
        </li>
        <li>
          <dl>
            <dt>핵심 관심 (Core Concerns)</dt>
            <dd>각 메소드에만 들어 있는 핵심 관심 코드을 의미한다.</dd>
          </dl>
        </li>
      </ul>
    </blockquote>
  </li>
</ul>

<p><img src="/img/posts/javaetc/aop.png" alt="aop" /></p>

<ul>
  <li>위 그림에서 Class A, Class B, Class C가 핵심 관심이다.</li>
  <li>주황색, 파란색, 빨간색 블럭이 횡단 관심이다.
    <blockquote>
      <ul>
        <li>반복되는 횡단 관심을 모듈화를 통해 분리하고 재사용하는 것이다.</li>
      </ul>
    </blockquote>
  </li>
</ul>

<p><br /></p>
<h4 id="aop가-왜-필요할까">AOP가 왜 필요할까?</h4>
<ul>
  <li>첫 번째 상황 : 비즈니스 메소드 속에는 모든 메소드가 가지고 있는 공통된 코드들과 각각의 메소드만 가지고 있는 핵심 코드가 있다. 공통된 로직을 매 메소드마다 반복하는 것은 유지 보수에 좋지 않다.</li>
  <li>두 번째 상황 : 모든 비즈니스 메소드의 실행 시간을 확인하거나, 모든 메소드 실행시 매번 log를 콘솔에 출력해야 한다면 모든 메소드에 일일히 해당 코드를 추가 작성하는 일은 어려우며 유지 보수에도 쉽지 않다.</li>
</ul>

<p><br /></p>

<h3 id="aop-상세-용어-정리">AOP 상세 용어 정리</h3>
<ul>
  <li>JointPoint : Advice가 일어날 수 있는 모든 비즈니스 메소드의 시점을 의미한다.</li>
  <li>Aspect(Advisor)  : Pointcut + Advice
    <blockquote>
      <ul>
        <li>Aspect(Advisor) :  Pointcut과 Advice의 결합(모듈화), Pointcut의 시점에 Advice가 실행되는 것을 의미한다.</li>
        <li>Pointcut : 횡단 관심(Advice)이 일어나는 시점을 의미한다. (필터링된 JointPoint)</li>
        <li>Advice : 횡단 관심에 해당하는 실행될 공통 기능의 코드를 의미한다.</li>
      </ul>
    </blockquote>
  </li>
</ul>

<p><br /></p>

<h3 id="aop-사용-방법">AOP 사용 방법</h3>
<ul>
  <li>.xml 파일-Namespaces-<code class="language-plaintext highlighter-rouge">aop</code> 사용 체크 (Eclipse 기준)</li>
  <li>.xml 작성</li>
</ul>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;beans&gt;</span> <span class="c">&lt;!--세부 내용 생략 --&gt;</span>

<span class="c">&lt;!--횡단 관심에 해당하는 Advice 클래스 빈 등록--&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"id"</span> <span class="na">class=</span><span class="s">"클래스 패키지 주소"</span><span class="nt">&gt;&lt;/bean&gt;</span>

<span class="c">&lt;!--AOP 설정 --&gt;</span>
	<span class="nt">&lt;aop:config&gt;</span>
		<span class="nt">&lt;aop:pointcut</span> <span class="na">id=</span><span class="s">"allPointcut"</span> <span class="na">expression=</span><span class="s">"execution(* com.naver.biz..*Service.*(..))"</span><span class="nt">/&gt;</span>
		
		<span class="nt">&lt;aop:aspect</span> <span class="na">ref=</span><span class="s">"id"</span><span class="nt">&gt;</span>
			<span class="nt">&lt;aop:after</span> <span class="na">pointcut-ref=</span><span class="s">"allPointcut"</span> <span class="na">method=</span><span class="s">"beanMethod"</span><span class="nt">/&gt;</span>
		<span class="nt">&lt;/aop:aspect&gt;</span>
		
	<span class="nt">&lt;/aop:config&gt;</span>
<span class="nt">&lt;/beans&gt;</span>

</code></pre></div></div>

<ul>
  <li>aspect에서 pointcut-ref= “allPointcut” 은 포인트 컷이 expression 필터링된 시점이다.</li>
  <li>allPointcut이 실행될 때 ref=”id” 인 bean 클래스의 beanMethod가 Advice로 실행된다.</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;aop:after ...&gt;</code> 는 동작 시점을 의미하며 before, after, after-returning, after-throwing, around 속성을 사용할 수 있다. (아래에서 더 설명)</li>
</ul>

<p><br /></p>

<h5 id="pointcut-expression-작성법">pointcut expression 작성법</h5>
<ul>
  <li>Advice가 실행되는 시점을 작성하는 것이다.</li>
  <li>excution() 명시자 내부에 작성한다.</li>
  <li><code class="language-plaintext highlighter-rouge">[리턴타입] [패키지 경로][클래스 이름].[메소드 이름 및 매개변수]</code></li>
  <li>리턴 타입 : 리턴 타입 뒤에 띄어쓰기
    <blockquote>
      <ul>
        <li><code class="language-plaintext highlighter-rouge">*</code> : 모든 리턴을 허용한다.</li>
        <li>void :  리턴 타입이 void인 메소드 필터링한다.</li>
        <li>!void : 리턴 타입이 void가 아닌 메소드 필터링한다.</li>
      </ul>
    </blockquote>
  </li>
  <li>패키지 경로
    <blockquote>
      <ul>
        <li>com.naver.biz.users : 정확한 패키지명으로 필터링한다.</li>
        <li>com.naver.biz..  : com.naver.biz로 시작하는 모든 패키지를 필터링한다.</li>
        <li>com.naver..users : com.naver로 시작하는 패키지 중 패키지 마지막이 user인 패키지를 필터링한다.</li>
      </ul>
    </blockquote>
  </li>
  <li>클래스 이름 : 클래스 이름 뒤에 .
    <blockquote>
      <ul>
        <li>UserService : UserService 클래스를 필터링한다.</li>
        <li>*Service : 클래스 이름이 Service로 끝나는 클래스를 필터링한다.</li>
      </ul>
    </blockquote>
  </li>
  <li>메소드 이름
    <blockquote>
      <ul>
        <li>insertUser : insertUser 메소드를 필터링한다.</li>
        <li>insert* : insert로 시작하는 모든 메소드를 필터링한다.</li>
      </ul>
    </blockquote>
  </li>
  <li>매개 변수
    <blockquote>
      <ul>
        <li>(..) : 모든 경우의 매개변수의 갯수와 타입 허용한다.</li>
        <li>(*) :  매개변수를 1개 받는 메소드를 필터링한다.</li>
        <li>(int, String) : int형, String형을 매개변수로 받는 메소드를 필터링한다.</li>
      </ul>
    </blockquote>
  </li>
  <li>예시
    <blockquote>
      <ul>
        <li>
          <dl>
            <dt><code class="language-plaintext highlighter-rouge">expression="execution(void com.naver..*Impl.get*(..))"</code></dt>
            <dd>리턴 타입이 void, com.naver.. 아래 모든 클래스 중 클래스 이름이 Impl로, 메소드 이름이 get으로 시작하는 모든 메소드를 필터링한다.</dd>
          </dl>
        </li>
        <li>
          <dl>
            <dt><code class="language-plaintext highlighter-rouge">expression="execution(* com.kakao.biz.*.*user(*,*))"</code></dt>
            <dd>com.kakao.biz 아래 모든 클래스, user로 끝나는 메소드이며 매개변수를 2개 받는 메소드를 필터링한다.</dd>
          </dl>
        </li>
      </ul>
    </blockquote>
  </li>
</ul>

<p><br /></p>

<h3 id="aop-동작-시점">AOP 동작 시점</h3>
<ul>
  <li>before : 비즈니스 메소드 실행 전 무조건 동작한다.</li>
  <li>after : 비즈니스 메소드 실행 후 무조건 동작한다.
    <blockquote>
      <ul>
        <li>after-returning : 비즈니스 메소드 실행 후 데이터를 return하고 Advice에서 인자로 받아 사용 가능하다.
          <blockquote>
            <ul>
              <li>.xml 파일에서 returning 속성으로 리턴할 데이터명을 설정할 수 있다. (유효성 검사에 사용할 수 있다.)</li>
              <li>비즈니스 메소드의 리턴 타입이 void이면 NullPointerException이 일어나니 주의해야 한다.</li>
            </ul>
          </blockquote>
        </li>
        <li>after-throwing : 비즈니스 메소드 실행시 예외 발생시 예외 객체를 return하고 Advice에서 인자로 받아 사용 가능하다.
          <blockquote>
            <ul>
              <li>.xml 파일에서 throwing 속성으로 리턴할 예외 변수명을 설정할 수 있다.</li>
            </ul>
          </blockquote>
        </li>
      </ul>
    </blockquote>
  </li>
  <li>around : 메소드 호출을 가로채 비즈니스 메소드 전후에 로직을 처리할 수 있다.
    <blockquote>
      <ul>
        <li>around Advice는 ProceedingJoinPoint 객체를 인자로 받아야 한다.</li>
      </ul>

      <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">Object</span> <span class="nf">aroundAdvice</span><span class="o">(</span><span class="nc">ProceedingJoinPoint</span> <span class="n">jp</span><span class="o">)</span>  <span class="kd">throws</span> <span class="nc">Throwable</span><span class="o">{</span>
		<span class="nc">String</span> <span class="n">method</span> <span class="o">=</span><span class="n">jp</span><span class="o">.</span><span class="na">getSignature</span><span class="o">().</span><span class="na">getName</span><span class="o">();</span>		
		<span class="nc">Object</span> <span class="n">returnObj</span> <span class="o">=</span><span class="kc">null</span><span class="o">;</span>
		
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"비즈니스 메소드 사전처리"</span><span class="o">)</span>
		
		<span class="n">returnObj</span> <span class="o">=</span> <span class="n">jp</span><span class="o">.</span><span class="na">proceed</span><span class="o">();</span>
		
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"비즈니스 메소드 사후처리"</span><span class="o">)</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">method</span><span class="o">+</span> <span class="s">"() 비즈니스 메소드 실행완료"</span><span class="o">);</span>
		
		<span class="k">return</span> <span class="n">returnObj</span><span class="o">;</span>
	<span class="o">}</span>
</code></pre></div>      </div>
    </blockquote>
  </li>
  <li>또한 ProceedingJoinPoint를 통해 메소드의 반환형, 이름, 매개변수 등의 정보를 얻을 수 있으며  around Advice만 ProceedingJoinPoint을 사용한다.</li>
  <li>ProceedingJoinPoint는 around Advice를 위한 preoceed() 메소드가 추가되어있다.</li>
  <li>나머지 Advice는 ProceedingJoinPoint의 부모인 JoinPoint 객체를 통해 메소드의 반환형, 이름, 매개변수 등의 정보를 얻을 수 있다.</li>
</ul>

<p><br /></p>

<h3 id="aop-annotation">AOP Annotation</h3>

<ul>
  <li>.xml 파일에  <code class="language-plaintext highlighter-rouge">&lt;aop:aspectj-autoproxy/&gt;</code>을 설정해준다.(<code class="language-plaintext highlighter-rouge">&lt;aop:config&gt;</code> 는 없어도 된다.)</li>
  <li>Advice 클래스에 <code class="language-plaintext highlighter-rouge">@Service</code>를 붙여 bean 등록을 대체한다.</li>
  <li>그리고 <code class="language-plaintext highlighter-rouge">@Aspect</code> 를 붙여 Aspect 역할을 할 클래스임을 나타낸다.</li>
  <li>클래스 내부에 참조형 메소드를 생성하여 <code class="language-plaintext highlighter-rouge">@Pointcut("execution(~)")</code> 을 생성한다.</li>
  <li>Advice 메소드 위
    <blockquote>
      <ul>
        <li><code class="language-plaintext highlighter-rouge">@Before("참조형 메소드명()")</code></li>
        <li><code class="language-plaintext highlighter-rouge">@After("참조형 메소드명()")</code></li>
        <li><code class="language-plaintext highlighter-rouge">@AfterReturning(pointcut="참조형 메소드명()", returning="변환데이터변수명")</code></li>
        <li><code class="language-plaintext highlighter-rouge">@AfterThrowing(pointcut="참조형 메소드명()", throwing="예외변수명")</code></li>
        <li><code class="language-plaintext highlighter-rouge">@Around("참조형 메소드명()")</code></li>
      </ul>
    </blockquote>
  </li>
  <li>Pointcut의 execution 식과 참조형 메소드를 묶어 클래스를 만들어 클래스명.메소드명으로 호출할 수도 있다.</li>
</ul>

<p><br /></p>
<h4 id="예시">예시</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span> <span class="c1">//bean 대신 객체 등록</span>
<span class="nd">@Aspect</span> <span class="c1">//Aspect 등록</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AroundAdvice</span> <span class="o">{</span>

	<span class="nd">@Pointcut</span><span class="o">(</span><span class="s">"execution(* com.naver.service..*service.*(..))"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">myPointcut</span><span class="o">()</span> <span class="o">{}</span> 
	
    <span class="nd">@Around</span><span class="o">(</span><span class="s">"myPointcut()"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="nc">Object</span> <span class="nf">aroundAdvice</span><span class="o">(</span><span class="nc">ProceedingJoinPoint</span> <span class="n">jp</span><span class="o">)</span>  <span class="kd">throws</span> <span class="nc">Throwable</span><span class="o">{</span>
		<span class="c1">//...생략</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span> <span class="c1">//bean 대신 객체 등록</span>
<span class="nd">@Aspect</span> <span class="c1">//Aspect 등록</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AfterReturningAdvice</span> <span class="o">{</span>

	<span class="nd">@Pointcut</span><span class="o">(</span><span class="s">"execution(void com.naver.data..*.*(..))"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">myPointcut</span><span class="o">()</span> <span class="o">{}</span> 
	
    <span class="nd">@AfterReturning</span><span class="o">(</span><span class="n">pointcut</span><span class="o">=</span><span class="s">"myPointcut()"</span><span class="o">,</span> <span class="n">returning</span> <span class="o">=</span><span class="s">"returnObject"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="nc">Object</span> <span class="nf">afterReturningAdvice</span><span class="o">(</span><span class="nc">JoinPoint</span> <span class="n">jp</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">returnObject</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span><span class="o">{</span>
		<span class="c1">//...생략</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<p><br />
Reference:</p>
<ul>
  <li><a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC_renew">inflean_img</a></li>
  <li><a href="https://engkimbs.tistory.com/746">AOP img_새로비</a></li>
  <li><a href="https://icarus8050.tistory.com/8">Spring AOP PointCut 표현식 정리_ Icarus</a>
-<a href="https://snoopy81.tistory.com/286">Advice타입별 클래스 작성_영혼과 영혼의 양식</a></li>
</ul>
:ET