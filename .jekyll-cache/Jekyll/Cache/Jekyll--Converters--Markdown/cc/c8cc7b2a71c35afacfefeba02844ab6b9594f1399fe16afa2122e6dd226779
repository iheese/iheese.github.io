I"?0<h4 id="프로세스와-스레드의-차이를-설명해보세요">프로세스와 스레드의 차이를 설명해보세요.</h4>
<ul>
  <li>프로세스는 운영체제로부터 자원을 할당 받는 작업의 단위</li>
  <li>스레드는 프로세스가 할당 받은 자원을 이용하는 실행의 단위</li>
  <li>운영 체제 <code class="language-plaintext highlighter-rouge">-&gt;</code> 프로세스 <code class="language-plaintext highlighter-rouge">-&gt;</code> 스레드</li>
  <li>운영체제는 시스템 자원을 효율적으로 관리하기 위해 스레드를 사용합니다.
    <blockquote>
      <ul>
        <li>멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있습니다. 프로세스 간의 통신보다 스레드 간의 통신의 비용이 적으므로 작업들 간의 통신 부담이 줄어듭니다.</li>
      </ul>
    </blockquote>
  </li>
  <li>스레드를 활용하면 자원의 효율성이 증가하지만 스레드 간의 자원 공유는 전역 변수를 공유하므로 동기화 문제에 신경 써야 합니다.
    <blockquote>
      <ul>
        <li>그래서 멀티 스레드 프로그래밍은 주의가 필요합니다.</li>
      </ul>
    </blockquote>
  </li>
</ul>

<p><br /></p>

<h4 id="컨텍스트-스위칭에-대해-설명해보세요">컨텍스트 스위칭에 대해 설명해보세요.</h4>
<ul>
  <li>
    <p>멀티 프로세스 환경에서 CPU(프로세서)가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때 기존 프로세스의 상태(or 레지스터값)를 저장하고 다음 프로세스를 수행하도록 교체하는 작업입니다.</p>
  </li>
  <li>
    <p>컨텍스트 스위칭이 일어나는 상황</p>
    <blockquote>
      <ul>
        <li>I/O interrupt</li>
        <li>CPU 사용시간 만료</li>
        <li>자식  프로세스 fork</li>
        <li>인터럽트 처리를 기다릴 때</li>
      </ul>
    </blockquote>
  </li>
</ul>

<p><br /></p>

<h4 id="동기와-비동기의-차이블로킹-넌블로킹--장단점에-대해-설명해보세요">동기와 비동기의 차이(블로킹, 넌블로킹) / 장단점에 대해 설명해보세요.</h4>
<ul>
  <li>동기는 순차적, 직렬적으로 태스크를 처리하고, 비동기는 병렬적으로 태스크를 처리합니다.</li>
  <li>동기의 상황에서 태스크를 처리할 때 뒤의 태스크는 블로킹(작업 중단)되고 대기하게 된다.
    <blockquote>
      <ul>
        <li>제어권을 태스크를 처리하는 대상이 가지고 있다.</li>
      </ul>
    </blockquote>
  </li>
  <li>비동기의 상황은 태스크를 병렬적으로 처리하기 때문에 논블로킹(대기하지 않고) 계속 수행하고 처리한다.
    <blockquote>
      <ul>
        <li>작업 완료 여부와 상관없이 계속 새로운 작업을 수행한다.</li>
      </ul>
    </blockquote>
  </li>
</ul>

<p><br /></p>

<h4 id="멀티스레드-프로그래밍에-대해-설명해보세요">멀티스레드 프로그래밍에 대해 설명해보세요.</h4>
<ul>
  <li>하나의 프로세스에서 여러 개의 스레드를 만들어 자원의 생성과 관리의 중복을 최소화하는 것을 의미합니다.</li>
  <li>장점
    <blockquote>
      <ul>
        <li>멀티 프로세스에 비해 메모리 자원 소모가 줄어든다.</li>
        <li>힙 영역을 통해 스레드끼리 통신이 가능하다.</li>
        <li>프로세스 컨텍스트 스위칭보다 스레드 컨텍스트 스위칭이 빠르다.</li>
      </ul>
    </blockquote>
  </li>
  <li>단점
    <blockquote>
      <ul>
        <li>힙 영역의 자원을 이용할 때는 동기화가 필요하다.</li>
        <li>동기화를 위해 락을 과도하게 사용하면 성능이 저하된다.</li>
        <li>하나의 스레드가 비정상적으로 동작하면 다른 스레드도 종료될 수 있다.</li>
      </ul>
    </blockquote>
  </li>
</ul>

<p><br /></p>

<h4 id="thread-safe-하다는-의미와-설계하는-법을-설명해보세요">Thread-safe 하다는 의미와 설계하는 법을 설명해보세요.</h4>

<ul>
  <li>
    <p>두 개 이상의 스레드가 race condition(경쟁 상태: 여러 프로세스나 스레드가 동기화 메커니즘 없이 자원에 접근하려는 상황)에 들어가거나 같은  객체에 동시에 접근해도 연산결과의 정합성이 보장될 수 있게끔 메모리 가시성이 확보된 상태를 의미한다.</p>
  </li>
  <li>
    <p>설계하는 법</p>
    <blockquote>
      <ul>
        <li>java.util.concurrent 패키지 하위의 클래스를 사용</li>
        <li>인스턴스 변수를 두지 않는다,</li>
        <li>Singleton 패턴을 사용</li>
        <li>동기화(syncronized) 블럭에서 연산을 수행
          <blockquote>
            <ul>
              <li>그래서 Spring을 사용하는 것, Spring은 Singleton Registry인 Application Context를 가지고 있다.</li>
              <li>Spring이 singleton을 사용하는 이유는 대규모 트래픽을 처리하기 위함</li>
              <li><a href="https://mangkyu.tistory.com/151">[Spring] 애플리케이션 컨텍스트(Application Context)와 스프링의 싱글톤(Singleton)_망나니개발자</a></li>
            </ul>
          </blockquote>
        </li>
      </ul>
    </blockquote>
  </li>
</ul>

<p><br /></p>

<h4 id="세마포어와-뮤텍스의-차이에-대해-설명해보세요">세마포어와 뮤텍스의 차이에 대해 설명해보세요.</h4>
<ul>
  <li>뮤텍스는 Lock을 사용해 하나의 프로세스나 스레드를 단독으로 실행하게 한다.
    <blockquote>
      <ul>
        <li>0, 1의 값만 가지는 세마포어, 이진 세마포어 = 뮤텍스</li>
      </ul>
    </blockquote>
  </li>
  <li>세마포어는 공유자원에 세마포어 변수(공유자원의 개수를 나타내는 변수)만큼 프로세스(또는 스레드)가 접근할 수 있다.</li>
  <li>세마포어는 다른 프로세스가 해제할 수 있지만, 뮤텍스는 락을 획득한 프로세스만 락을 해체할 수 있습니다.</li>
</ul>

<p><br /></p>

<h4 id="프로세스-동기화에-대해-설명해보세요">프로세스 동기화에 대해 설명해보세요.</h4>
<ul>
  <li>다중 프로세스 환경에서 자원에 한 프로레스만 접근 가능하게 하는 것을 의미한다.</li>
  <li>프로세스 동기화를 하지 않으면 데이터의 일관성이 깨져 연산 결과의 에러가 뜰 수 있으므로 주의해야 한다.</li>
</ul>

<p><br /></p>

<h4 id="교착상태와-기아상태의-해결방법에-대해-설명해보세요">교착상태와 기아상태의 해결방법에 대해 설명해보세요.</h4>
<ul>
  <li>교착상태(Deadlock) : 서로 다른 프로세스가 서로 점유하고 있는 자원의 반납을 대기하고 있는 상태입니다.</li>
  <li>발생 조건
    <blockquote>
      <ul>
        <li>상호 배제 : 한 번에 한 프로세스만 해당 자원을 사용할 수 있어야 합니다.</li>
        <li>점유 대기 : 할당된 자원을 가진 상태에서 다른 자원을 기다립니다.</li>
        <li>비선점 : 다른 프로세스가 자원의 사용을 끝낼 때까지 자원을 뺏을 수 없습니다.</li>
        <li>순환 대기 : 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있습니다.</li>
      </ul>
    </blockquote>
  </li>
  <li>해결 방법
    <blockquote>
      <ul>
        <li>예방 : 위 4가지 조건 중 하나라도 만족하지 않도록 합니다.</li>
        <li>회피 : 알고리즘에 데드락을 발생하지 않도록 합니다.</li>
        <li>회복 : 데드락이 발생했을 때 해결합니다.</li>
        <li>무시 : 회복과정의 성능 저하가 심하다면 그냥 무시합니다.</li>
      </ul>
    </blockquote>
  </li>
  <li>기아 상태(Starvation) : 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때, 특정 프로세스가 영원히 자원 할당이 되지 않는 경우를 말합니다.</li>
  <li>해결방법
    <blockquote>
      <ul>
        <li>우선 순위를 변경합니다.
          <blockquote>
            <ul>
              <li>우선 순위를 수시로 변경해준다.</li>
              <li>오래 기다린 프로세스의 우선 순위를 높여준다.</li>
              <li>Queue를 사용합니다.</li>
            </ul>
          </blockquote>
        </li>
      </ul>
    </blockquote>
  </li>
</ul>

<p><br /></p>

<h4 id="가상-메모리에-대해-설명해보세요">가상 메모리에 대해 설명해보세요.</h4>
<ul>
  <li>물리적 메모리의 한계를 이겨내고자 실제 크기와 상관없이 메모리를 사용할 수 있게 지원하는 기술입니다.</li>
  <li>가상 메모리는 실제 메모리(RAM, Main memory, first storage)와 보조 기억 장치(Auxiliary storage,secondary storage)의 Swap 영역으로 구성됩니다.</li>
  <li>OS는 메모리 관리자를 통해 메모리를 관리하며 프로세스는 사용하는 메모리가 실제 메모리인지 Swap 영역인지 모릅니다.</li>
  <li>Java에서는 Swap 영역을 잡아주지 않으면 OOM(Out of Memory)이 발생할 수 있습니다.
    <blockquote>
      <ul>
        <li>Swap 영역은 실제 메모리가 아니기 때문에 지연시간이 많이 발생합니다. 가급적이면 Swap 메모리를 사용하지 않게 설계하는 것이 좋고, 만약 계속 사용량이 증가한다면 메모리 누수를 의심해볼 필요가 있습니다.</li>
      </ul>
    </blockquote>
  </li>
</ul>

<p><br /></p>

<h4 id="페이지-교체-알고리즘이란">페이지 교체 알고리즘이란?</h4>
<ul>
  <li>운영체제는 주기억장치(RAM)보다 더 큰 용량의 프로그램을 실행하기 위해 프로그램의 일부만 주기억장치에 적재하여 사용하는 것을 가상 메모리 기법이라 한다.</li>
  <li>페이징 기법으로 메모리를 관리하는 운영체제에서 필요한 페이지가 주기억 장치에 적재되지 않았을 시(페이징 부재시) 어떤 페이지 프레임을 선택해 교체할 것인지 결정하는 방법을 페이지 교체 알고리즘이라 합니다.</li>
  <li>LRU(Least Recently Used)
    <blockquote>
      <ul>
        <li>가장 오래 사용되지 않은 페이지를 교체하는 알고리즘입니다.</li>
        <li>OPT(최적 페이지 교체)와 비슷한 효과를 낼 수 있으며, OPT보다 페이지 교체 횟수가 높지만 FIFO(First In First Out) 알고리즘 보다 효율적입니다.</li>
      </ul>
    </blockquote>
  </li>
  <li>FIFO(First In First Out) : 첫번째로 들어간 것이 첫번째로 나오는 교체 방식</li>
  <li>최적(Optimal) 페이지 교체 : 앞으로 가장 오랫동안 사용되지 않을 페이지 교체</li>
  <li>LFU(Least-Frequently-Used) : 참조 횟수가 가장 작은 페이지 교체</li>
  <li>MFU(Most-Frequently-Used) : 참조 횟수가 가장 많은 페이지 교체</li>
  <li>NUR(Not Used Recently) : 최근에 사용하지 않은 페이지 교체</li>
</ul>

<p><br /></p>

<h4 id="캐시의-지역성에-대해-설명해보세요">캐시의 지역성에 대해 설명해보세요.</h4>
<ul>
  <li>시간 지역성과 공간 지역성으로 나눌 수 있습니다.</li>
  <li>시간 지역성 : 최근에 접근한 데이터에 다시 접근하는 경향을 의미합니다.</li>
  <li>공간 지역성 : 최근에 접근한 데이터의 주변 공간에 다시 접근하는 경향을 의미합니다.</li>
</ul>

<p><br /></p>

<h4 id="추가-학습할-부분">추가 학습할 부분</h4>

<p><br /></p>

<p>Reference:</p>
<ul>
  <li><a href="https://github.com/ksundong/backend-interview-question">Backend-Interview-Question_ ksundong</a></li>
  <li><a href="https://brunch.co.kr/@kd4/3">프로세스와 스레드의 차이_강관우</a></li>
  <li><a href="https://dev-coco.tistory.com/162">신입 개발자 기술면접 질문 정리 - 운영체제)_슬기로운 개발 생활</a></li>
</ul>
:ET